%require "3.2"
%language "c++"
%debug
%defines
%define api.namespace {voila}
%define api.parser.class {Parser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.error verbose

%output  "src/voila_parser.cpp"
%defines "include/voila_parser.hpp"
%locations
%define api.location.file "include/location.hpp"

%code provides
{
    #define YY_DECL \
        int yylex(calc::Parser::semantic_type *yylval, yyscan_t yyscanner)
    YY_DECL;
}

%code requires {
  namespace voila {
    class Lexer;  // Generated by reflex with namespace=voila lexer=Lexer lex=yylex
  }
}
%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer

%code {
#include <iostream>
#include <cstdlib>
#include <fstream>
#include "voila_lexer.hpp"
#undef yylex
#define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()
}

%define api.token.prefix {TOK_}
%initial-action { yyset_extra(0, scanner); }

/* literals */
%token TRUE FALSE
/* special functions */
%token LOOP FUNCTION EMIT MAIN
/* comparison */
%token EQ NEQ LE LEQ GE GEQ
/* arithmetic */
%token ADD SUB MUL DIV MOD
/* logical */
%token AND OR NOT
/* unary operators */
%token HASH SELTRUE SELFALSE //TODO
/* binary operators */
%token GATHER READ //TODO
/* ternary operators */
%token SCATTER WRITE
/* aggregates */
%token AGGR SUM CNT MIN MAX AVG
/* TODO hash table ops */

%nonassoc ASSIGN

%token <int64_t> INT
%token <double> FLT
%token <std::string> ID
%token <std::string> STR

%nterm <std::vector<Statement>> stmts; 
%nterm <std::vector<Expression>> expr_list;
%nterm <std::vector<Fun>> program;
%nterm <std::unordered_set<ID>> IDs;
%nterm <Statement> stmt;
%nterm <Expression> expr;
%nterm <Fun> func;
%nterm <Main> main;
%nterm <Const> constant; 
%nterm <Predicate> pred; 
%nterm <Effect> effect;
%nterm <Arithmetic> arithmetic;
%nterm <Comparison> comparison;
%nterm <Logical> logical;
%nterm <Fun> read_op;

%%
program: 
	%empty { }
	| program func { $$ = $1; $$.emplace_back($2); }
	| program main { $$ = $1; $$.emplace_back($2); }

func: FUNCTION ID '(' IDs ')' '{' stmts '}' { $$ = Fun($2, $7, $4); }

main: MAIN '{' stmts '}' { $$ = Main($3); }

stmts:
	%empty { }
	| stmts stmt { $$ = $1; $$.push_back($2); }

stmt: expr ';' { $$ = veclang_new_node1(scanner, VLN_ExecExpr, $1); }
	| ID '=' expr ';' { $$ = Assign($1, $3); }
	| LOOP pred '{' stmts '}' { $$ = Loop($2, $4); }
	| EMIT expr ';' { $$ = Emit($2); }
	| effect ';' { $$ = $1; }

	/* aggregate ( result_store, variable with predicate as aggregation filter, vector_to_aggregate) */
effect :
	AGGR '(' SUM ',' ID ',' expr ',' expr ')' { $$ = AggrGSum($5, $7, $9); } /* maybe we restrict the expressions to more specialized predicates or tuple get in the parser to safe some correctness check effort later on */
	| AGGR '(' CNT',' ID ',' expr ',' expr ')' { $$ = AggrGCount(($5, $7, $9)); }
	| AGGR '('AVG',' ID ',' expr ',' expr ')' { $$ = AggrGAvg(($5, $7, $9)); }
	| AGGR '('MIN',' ID ',' expr ',' expr ')' { $$ = AggrGMin(($5, $7, $9)); }
	| AGGR '('MAX',' ID ',' expr ',' expr ')' { $$ = AggrGMax(($5, $7, $9)); }
	| SCATTER '(' ID ',' expr pred ',' expr ')' { $$ = Scatter($3, $5, $8, $6); } /* dest, idxs with pred, src */
	| WRITE '(' ID ',' expr ','  ID ')' { $$ = Write($3, $5, $7, nullptr); } /* dest, start_idx, src */

pred: '|' ID { $$ = veclang_new_node1(scanner, VLN_Predicate, $2); } /* FIXME */

predicate:
	SELTRUE '(' expr ')'
	| SELFALSE '(' expr ')'

expr: 
	constant { $$ = $1; }
	| ID { $$ = Ref($1); }
	| ID '[' INT ']' { $$ = TupleGet($1, $3); }
	| '(' expr_list ')' { $$ = veclang_new_node1(scanner, VLN_CreateTuple, $2); } /* recursive tuples do not look like a good idea */
	| expr pred { $$ = veclang_set_predicate($1, $2);}
	| ID '(' expr ')' { $$ = veclang_new_node2(scanner, VLN_Call, $1, $3); }
	| arithmetic {$$ = $1; }
	| comparison {$$ = $1; }
	| logical {$$ = $1; }
	| read_op {$$ = $1; }

constant:
	TRUE { $$ = Const(true); }
	| FALSE { $$ = Const(false); }
	| INT { $$ = Const($1); }
	| FLT { $$ = Const($1); }
	| STR { $$ = Const($1); }

arithmetic :
	ADD '('expr',' expr ')' {$$ = Arithmetic(Arithmetic::Operation::ADD, $3, $5); }
	| SUB '('expr',' expr ')' {$$ = Arithmetic(Arithmetic::Operation::SUB, $3, $5); }
	| MUL '('expr',' expr ')' {$$ = Arithmetic(Arithmetic::Operation::MUL, $3, $5); }
	| DIV '('expr',' expr ')' {$$ = Arithmetic(Arithmetic::Operation::DIV, $3, $5); }
	| MOD'('expr',' expr ')' {$$ = Arithmetic(Arithmetic::Operation::MOD, $3, $5); }

comparison : 
	EQ '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::EQ, $3, $5); }
	| NEQ '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::NEQ, $3, $5); }
	| LE '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::LE, $3, $5); }
	| LEQ '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::LEQ, $3, $5); }
	| GE '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::GE, $3, $5); }
	| GEQ '('expr',' expr ')' {$$ = Comparison(Comparison::Operation::GEQ, $3, $5); }

logical:
	AND '('expr',' expr ')' {$$ = Comparison(Logical::Operation::AND, $3, $5); }
 	| OR '('expr',' expr ')' {$$ = Comparison(Logical::Operation::OR, $3, $5); }
 	| NOT '(' expr ')' {$$ = Comparison(Logical::Operation::NOT, $3); }

read_op:
	GATHER '(' expr ',' expr ')' { $$ = Gather($3, $5); }
	| READ '(' expr ',' expr ')' { $$ = Read($3, $5); }


expr_list: 
	%empty { }
	| expr_list ',' expr { $$ = $1; $$.push_back($3); }

IDs :
	%empty { }
	| IDs ',' ID {$$ = $1; $$.insert($3); }
%%


void Voila::Parser::error(const location& loc, const std::string& msg)
{
  std::cerr << loc << ": " << msg << std::endl;
  if (lexer.size() == 0)      // if token is unknown (no match)
    lexer.matcher().winput(); // skip character
}