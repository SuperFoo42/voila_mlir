%require "3.2"
%language "c++"

%define api.namespace {voila::parser}
%define api.parser.class {Parser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.error verbose

%{
	#include "ASTNodes.hpp"
	#include "ast/ASTNodeVariant.hpp"
	#include "Program.hpp"
%}

%debug
%defines
%locations

%code requires {
	namespace voila::lexer {
		class Lexer; // Generated by reflex with namespace=voila lexer=Lexer lex=yylex
	}
}
%parse-param { voila::lexer::Lexer& lexer } {voila::Program &out}// Construct parser object with lexer and output

%code {
	#include <iostream>
	#include <cstdlib>
	#include <fstream>
	#include <string>
	#include <cinttypes>
	#include <vector>
	#include <memory>
	#pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wsuggest-override"
    #pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
	#include "voila_lexer.hpp"
	#pragma GCC diagnostic pop

	#undef yylex
	#define yylex lexer.lex // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()
}

%define api.token.prefix {TOK_}

/* special chars */
%token BAR "|"
%token COLON ";"
%token COMMA ","
%token LPAREN "("
%token RPAREN ")"
%token LBRACE "{"
%token RBRACE "}"
%token LBRACKET "["
%token RBRACKET "]"

/* literals */
%token TRUE "true"
%token FALSE "false"

/* special functions */
%token LOOP "loop"
%token FUNCTION "function definition"
%token EMIT "emit"
%token MAIN "main function"

/* comparison */
%token EQ "equals" 
%token NEQ "not equals"
%token LE "less"
%token LEQ "less equals"
%token GE "greater"
%token GEQ "greater equals"

/* arithmetic */
%token ADD "addition"
%token SUB "subtraction"
%token MUL "multiplication"
%token DIV "division"
%token MOD "modulo"

/* logical */
%token AND "and"
%token OR "or"
%token NOT "not"

%token SELECT "matching selection"
%token LOAD "selective load"

/* binary operators */
%token GATHER "gather"
%token READ "read"
/* ternary operators */
%token SCATTER "scatter"
%token WRITE "write"
/* aggregates */
%token AGGR "aggr"
%token SUM "sum"
%token CNT "count"
%token MIN "min"
%token MAX "max"
%token AVG "avg"

%token HASH "hash"
%token LOOKUP "lookup"
%token INSERT "insert"

%nonassoc ASSIGN "assignment"

%token <intmax_t> INT "integer"
%token <double> FLT "decimal"
%token <std::string> ID "identifier"
%token <std::string> STR "string literal"

%nterm <std::vector<ast::ASTNodeVariant>> stmts;
%nterm <std::vector<ast::ASTNodeVariant>> expr_list;
%nterm <std::vector<ast::ASTNodeVariant>> program;
%nterm <ast::ASTNodeVariant> stmt;
%nterm <ast::ASTNodeVariant> function_call;
%nterm <ast::ASTNodeVariant> expr;
%nterm <ast::ASTNodeVariant> func;
%nterm <ast::ASTNodeVariant> main;
%nterm <ast::ASTNodeVariant> constant;
%nterm <ast::ASTNodeVariant> bool_constant;
%nterm <ast::ASTNodeVariant> pred;
%nterm <ast::ASTNodeVariant> pred_expr;
%nterm <ast::ASTNodeVariant> var;
%nterm <std::vector<ast::ASTNodeVariant>> var_list;
%nterm <std::vector<ast::ASTNodeVariant>> params;
%nterm <ast::ASTNodeVariant> effect;
%nterm <ast::ASTNodeVariant> arithmetic;
%nterm <ast::ASTNodeVariant> comparison;
%nterm <ast::ASTNodeVariant> selection;
%nterm <ast::ASTNodeVariant> logical;
%nterm <ast::ASTNodeVariant> read_op;
%nterm <ast::ASTNodeVariant> aggregation;
%start program

%%
program: 
	%empty { }
	| func program { out.add_func($1); }
	| main prog_no_main { out.add_func($1); }

prog_no_main:
    %empty { }
    | func prog_no_main { out.add_func($1); }

func: FUNCTION ID params LBRACE stmts RBRACE { $$ = ASTNodeVariant(std::make_shared<ast::Fun>(@0+@5,$2, $3, $5)); }

main: MAIN params LBRACE stmts RBRACE { $$ = ASTNodeVariant(std::make_shared<ast::Main>(@0+@4,$2, $4)); }

params: LPAREN var_list RPAREN { $$ = $2; }
        | LPAREN RPAREN { $$ = std::vector<ast::ASTNodeVariant>(); }

stmts:
	%empty { }
	| stmts stmt { $$ = $1; $$.push_back($2); }

stmt: expr COLON { $$ = std::make_shared<ast::StatementWrapper>(@0,$1); }
    | var_list ASSIGN function_call COLON { $$ = std::make_shared<ast::Assign>(@2,$1, $3);  }
	| var_list ASSIGN expr COLON { $$ = std::make_shared<ast::Assign>(@2,$1, std::make_shared<ast::StatementWrapper>(@3,$3));  }
	| LOOP pred LBRACE stmts RBRACE { $$ = std::make_shared<ast::Loop>(@0+@2,$2, $4); }
	| EMIT expr_list COLON { $$ = std::make_shared<Emit>(@0,$2);  }
	| effect COLON { $$ = $1; }
	| effect COLON pred { $$ = $1; /* $$->set_predicate($3); */ }
	| function_call COLON { $$ = $1; }

function_call: ID params { $$ = std::make_shared<ast::FunctionCall>(@0+@2,$1, $2); }

var: ID {$$ = out.has_var($1) ? ast::ASTNodeVariant(std::make_shared<ast::Ref>(@0, out.get_var($1))) : ast::ASTNodeVariant(std::make_shared<ast::Variable>(@0, $1)); if (std::holds_alternative<std::shared_ptr<ast::Variable>>($$)){ out.add_var($$);};  };

	/* aggregate ( result_store, variable with predicate as aggregation filter, vector_to_aggregate) */
effect:
	 WRITE LPAREN expr COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::Write>(@0+@8,$3, $5, $7); } /* src, dest, start_idx */

aggregation:
    AGGR LPAREN SUM COMMA expr RPAREN { $$ = std::make_shared<ast::AggrSum>(@0+@6,$5); } /*simple aggregation */
	| AGGR LPAREN CNT COMMA expr RPAREN { $$ = std::make_shared<ast::AggrCnt>(@0+@6,$5); } /*simple aggregation */
	| AGGR LPAREN AVG COMMA expr RPAREN { $$ = std::make_shared<ast::AggrAvg>(@0+@6,$5); } /*simple aggregation */
	| AGGR LPAREN MIN COMMA expr RPAREN { $$ = std::make_shared<ast::AggrMin>(@0+@6,$5); } /*simple aggregation */
	| AGGR LPAREN MAX COMMA expr RPAREN { $$ = std::make_shared<ast::AggrMax>(@0+@6,$5); } /*simple aggregation */
    | AGGR LPAREN SUM COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::AggrSum>(@0+@8,$5, $7); } /* group based aggregation */
    | AGGR LPAREN CNT COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::AggrCnt>(@0+@8,$5, $7); } /* group based aggregation */
    | AGGR LPAREN AVG COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::AggrAvg>(@0+@8,$5, $7); } /* group based aggregation */
    | AGGR LPAREN MIN COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::AggrMin>(@0+@8,$5, $7); } /* group based aggregation */
    | AGGR LPAREN MAX COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::AggrMax>(@0+@8,$5, $7); } /* group based aggregation */

pred: BAR pred_expr { $$ = std::make_shared<ast::Predicate>(@2,$2); }

selection:
	SELECT LPAREN expr COMMA expr RPAREN { $$ = std::make_shared<ast::Selection>(@0+@4,$3, $5); }

expr: 
	constant { $$ = $1; }
	| var
	| expr pred { $$ = $1; /* $$.set_predicate($2); */ }
	| arithmetic {$$ = $1; }
	| comparison {$$ = $1;  }
	| logical {$$ = $1; }
	| read_op {$$ = $1;  }
	| selection { $$ = $1; }
	| LOAD LPAREN expr COMMA expr COMMA expr RPAREN { $$ = std::make_shared<ast::Load>(@0+@4,$3, $5, $7); }
	| aggregation {$$ = $1; }
	| HASH LPAREN expr_list RPAREN { $$ = std::make_shared<ast::Hash>(@0+@4, $3); }
	| LOOKUP LPAREN expr_list RPAREN {  auto hashes = $3.back(); $3.pop_back(); const auto half = $3.size() / 2;
	                                    auto values = std::vector<ast::ASTNodeVariant>($3.begin(),$3.begin()+half);
	                                    auto hashtables = std::vector<ast::ASTNodeVariant>($3.begin()+half,$3.end());
	                                    $$ = std::make_shared<ast::Lookup>(@0+@4, values, hashtables,hashes); } /* values, hashtables, hashes */
	| INSERT LPAREN expr COMMA expr_list RPAREN { $$ = std::make_shared<ast::Insert>(@0+@6,$3, $5); } /* keys, values */
	| SCATTER LPAREN expr COMMA expr RPAREN { $$ = std::make_shared<ast::Scatter>(@0+@6,$3, $5); } /* idxs with pred, src */

/* TODO: is this correct/complete? */
pred_expr:
    ID { $$ = std::make_shared<ast::Ref>(@0,out.get_var($1)); }
    | comparison {$$ = $1; }
    | logical {$$ = $1; }
    | bool_constant { $$= $1; }

constant:
    bool_constant { $$= $1; }
	| INT { $$ = std::make_shared<ast::IntConst>(@0,$1);  }
	| FLT { $$ = std::make_shared<ast::FltConst>(@0,$1); } //TODO: decimal
	| STR { $$ = std::make_shared<ast::StrConst>(@0,$1); }

bool_constant:
    TRUE { $$ = std::make_shared<ast::BooleanConst>(@0,true);  }
    | FALSE { $$ = std::make_shared<ast::BooleanConst>(@0, false); }

arithmetic :
	ADD LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Add>(@0+@6,$3, $5); }
	| SUB LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Sub>(@0+@6,$3, $5); }
	| MUL LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Mul>(@0+@6,$3, $5); }
	| DIV LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Div>(@0+@6,$3, $5); }
	| MOD LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Mod>(@0+@6,$3, $5); }

comparison : 
	EQ LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Eq>(@0+@6,$3, $5); }
	| NEQ LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Neq>(@0+@6,$3, $5); }
	| LE LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Le>(@0+@6,$3, $5); }
	| LEQ LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Leq>(@0+@6,$3, $5); }
	| GE LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Ge>(@0+@6,$3, $5); }
	| GEQ LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Geq>(@0+@6,$3, $5); }

logical:
	AND LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::And>(@0+@6,$3, $5); }
 	| OR LPAREN expr COMMA expr RPAREN {$$ = std::make_shared<ast::Or>(@0+@6,$3, $5); }
 	| NOT LPAREN expr RPAREN {$$ = std::make_shared<ast::Not>(@0+@4,$3); }

read_op:
	GATHER LPAREN expr COMMA expr RPAREN { $$ = std::make_shared<ast::Gather>(@0+@6,$3, $5); }
	| READ LPAREN expr COMMA expr RPAREN { $$ = std::make_shared<ast::Read>(@0+@6,$3, $5); }

expr_list: 
	expr { $$ = std::vector<ast::ASTNodeVariant>(); $$.push_back($1);}
	| expr_list COMMA expr { $$ = $1; $$.push_back($3); }

var_list:
    var {$$ = std::vector<ast::ASTNodeVariant>(); $$.push_back($1);};
    | var_list COMMA var {$$ = $1; $$.push_back($3); };

%%


void voila::parser::Parser::error(const location& loc, const std::string& msg)
{
	std::cerr <<
	loc << ": " << msg << std::endl;
	if (lexer.size() == 0) // if token is unknown (no match)
		lexer.matcher().winput(); // skip character
}